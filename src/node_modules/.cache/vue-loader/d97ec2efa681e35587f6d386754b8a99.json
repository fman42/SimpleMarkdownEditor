{"remainingRequest":"/usr/local/lib/node_modules/@vue/cli-service-global/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/fman/Desktop/SimpleMarkdown/src/SimpleMarkdown.vue?vue&type=style&index=0&id=38a6bd22&scoped=true&lang=css&","dependencies":[{"path":"/Users/fman/Desktop/SimpleMarkdown/src/SimpleMarkdown.vue","mtime":1608362566837},{"path":"/usr/local/lib/node_modules/@vue/cli-service-global/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/usr/local/lib/node_modules/@vue/cli-service-global/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/usr/local/lib/node_modules/@vue/cli-service-global/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/usr/local/lib/node_modules/@vue/cli-service-global/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/usr/local/lib/node_modules/@vue/cli-service-global/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCi5zaW1wbGUtbWFya2Rvd24gewogICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjsKICAgIGJvcmRlci1yYWRpdXM6IDVweDsKfQoKLnNpbXBsZS1tYXJrZG93bl9fZmllbGQgewogICAgcmVzaXplOiBub25lOwogICAgYm9yZGVyOiBub25lOwogICAgb3V0bGluZTogbm9uZTsKICAgIHBhZGRpbmc6IDVweDsKICAgIHdpZHRoOiAxMDAlOwogICAgaGVpZ2h0OiAxMDBweDsKfQo="},{"version":3,"sources":["SimpleMarkdown.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0JA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"SimpleMarkdown.vue","sourceRoot":".","sourcesContent":["<template>\n    <div class=\"simple-markdown\" id=\"markdown_editor\">\n        <!-- Toolbar -->\n        <Toolbar :disabledTools=\"disabledTools\" v-on:action=\"executeToolCallback\"></Toolbar>\n        <!-- Field -->\n        <textarea class=\"simple-markdown__field\" ref=\"field\" v-on:change=\"saveTextareaHistory()\" v-model=\"content\">\n            \n        </textarea>\n        <!-- Modals -->\n        <InformationModal v-show=\"modalsVisible.information\"></InformationModal>\n    </div>\n</template>\n\n<script>\n    import Toolbar from './Toolbar.vue';\n    import InformationModal from './Modals/Information.vue';\n\n    export default {\n        name: 'SimpleMarkdown',\n        props: {\n            disabledTools: {\n                type: Array,\n                default: () => {\n                    return [];\n                }\n            },\n            autoSave: {\n                type: Number,\n                default: () => {\n                    return 5000;\n                }\n            }\n        },\n        data() {\n            return {\n                content: '',\n                modalsVisible: {\n                    information: false\n                }\n            }\n        },\n        created() {\n            this.historyStack = [];\n            this.currentIndexHistoryStack = 0;\n        },\n        mounted() {\n            if (isNaN(this.autoSave))\n                return;\n\n            setTimeout(() => {\n                this.saveTextareaHistory();\n            }, this.autoSave);\n        },\n        methods: {\n            /*\n                Toolbar' callbacks\n            */\n            getBranchFromHistory(isUndo) {\n                this.content = this.fetchContentFromHistory(isUndo);\n            },\n\n            applyFormat(additionalSymbols) {\n                if (this.$refs.field.selectionStart !== this.$refs.field.selectionEnd){\n                    const substring = additionalSymbols + `${this.selectedText}` + additionalSymbols;\n                    this.content = this.joinContentWithEditedText(substring);\n                } else \n                    this.content = additionalSymbols + `${this.content}` + additionalSymbols;\n\n                this.saveTextareaHistory();\n            },\n\n            showInformationModal() {\n                this.modalsVisible.information = !this.modalsVisible.information;\n            },\n\n            applyHeading(symbols) {\n                this.content = `${symbols} ${this.selectedText}`; \n            },\n\n            changeCase(toCase) {\n                let updatedContent = this.content;\n\n                switch (toCase) {\n                    case 'upper': {\n                        updatedContent = updatedContent.toUpperCase();\n                        break;\n                    }\n                    case 'lower': {\n                        updatedContent = updatedContent.toLowerCase();\n                        break;\n                    }\n                    default: console.error('Case for the content is not found'); break;\n                }\n\n                this.content = this.joinContentWithEditedText(updatedContent);\n                this.saveTextareaHistory();\n            },\n\n            clearArea() {\n                this.content = '';\n            },\n\n            /*\n                Component' functions\n            */\n            saveTextareaHistory() {\n                const val = this.content.trim();\n\n                if (val.length === 0 || this.historyStack.includes(val))\n                    return;\n\n                this.historyStack.push(val);\n                this.currentIndexHistoryStack = this.historyStack.length - 1;\n            },\n\n            joinContentWithEditedText(editedText) {\n                return this.content.slice(0, this.$refs.field.selectionStart) + editedText + this.content.slice(this.$refs.field.selectionEnd, this.content.length);\n            },\n\n            executeToolCallback(callback) {\n                if (typeof callback === 'function')\n                    return callback.call();\n\n                if (typeof this[callback.name] !== 'function')\n                    return console.error('Method is not found: ' + callback.name);\n\n                const params = typeof callback['arguments'] !== \"object\" ? [] : callback.arguments;\n                this[callback.name].apply(this, params);\n            },\n\n            fetchContentFromHistory(isUndoAction = true) {\n                if (this.currentIndexHistoryStack === 0 && isUndoAction)\n                {\n                    this.content = '';\n                    return;\n                }\n\n                this.currentIndexHistoryStack = this.currentIndexHistoryStack - (isUndoAction ? 1 : -1);\n                return this.historyStack[this.currentIndexHistoryStack];\n            }\n        },\n        computed: {\n            selectedText: function() {\n                return this.content.slice(this.$refs.field.selectionStart, this.$refs.field.selectionEnd);\n            }\n        },\n        components: {\n            Toolbar,\n            InformationModal\n        }\n    }\n</script>\n\n<style scoped>\n    .simple-markdown {\n        background-color: #ffffff;\n        border-radius: 5px;\n    }\n\n    .simple-markdown__field {\n        resize: none;\n        border: none;\n        outline: none;\n        padding: 5px;\n        width: 100%;\n        height: 100px;\n    }\n</style>"]}]}